Программист -- Отправить сообщение в ответ на действие пользователя: !func
  # Прямо внутри метода обработки input

Программист -- Сохранить в стейте id только что отправленного сообщения: !func
  # FIXME Как? Запись в стейт == изменение состояния с сохранением класса состояния

Программист — Промигрировать стейт-машину: !function
  Нет персистенции: !story  # Достаточно перезапустить программу
  Персистенция, но данные протухают за несколько дней: !story  # Достаточно преобразования в момент чтения состония из БД
  Персистенция с протухающими данными, но канареечная схема релизов: !story  # С БД работает одновременно и старая и новая версия кода
  Вечная персистенция: !story  # Нужен аналог миграции схемы БД

Программист — Сохранить и восстановить стейт-машину между запусками: !function
  локатор не найден: !story

Программист — Параметризовать класс состояний: !function

Программист — Добавить обработчик события: !function
  on_chunk received: !story  # парсер бинарного файла
  on_message чат-бот: !story  # от пользователя прилетело текстовое сообщение
  on_enter + on_leave чат-бот: !story  # кнопочный чат-бот, хотим деактивировать кнопки под сообщением после
  HTTP POST, GET, PATCH: !story

# TODO Программист — Отрисовать схему и приложить документацию к ней: !function
# swagger-like

# TODO Исключено: На один URL зарегистрировать разные схемы данных

# TODO
# Программист — Совместить несколько роутеров в одном: !function
#   Подключить third party роутер к tg-боту: !story
#   Раскидать код tg-бота по разным модулям: !story

Программист — Найти пример использования: !func

Программист — Сравнить фреймворк с другими решениями: !func
  Популярные Python библиотеки: !story
  Автогенерённые из DSL стейт-машинами: !story
  Стейт-машина aiogram: !story

Программист — Подключить фреймворк: !func
  Уже существующий проект: !story
  Новый проект с нуля: !story
  Облачное решение: !extension

# TODO Добавить поддержку относительный адресов, при которой часть атрибутов заполняется автоматически
# Пример с парсером Dicom: сразу пять State для обработки body, и всем им нужны одни и те же аттрибуты
# Каждый раз в route.locate приходится передавать всё тот же набор аргументов:
# return router.locate(
#     '/body/fixed_length_tag_payload/',
#     vr_is_implicit=self.vr_is_implicit,
#     endian_is_little=self.endian_is_little,
#     ...


# TODO Нужен ещё один декоратор для ускорения отладки -- перехватываем исключения внутри стейта и отправляем
# пользователю сообщение в Tg с трейсбеком, адресом состояния и его параметрами. Так программист быстрее заметит
# где и в какой момент случился сбой.
# Такой декоратор пригодится при отладке в local-окружении, а на сервере его можно отключить.


# Ещё идеи для отладочных команд:
# - /pwd — вывести локатор текущего стейта и значения параметров в формате, пригодном для быстрого копирования
# - /cd ${...json_params...} — перевести стейт машину в указанный стейт
# - /trace on/off — включить/выключить трассировку стейтов, чтобы при каждом переходе из старого стейта в новый бот присылал программисту в Tg локатор и параметры нового стейта
# - /freeze on/off — заморозить текущий стейт, отключив все переходы, чтобы отладить методы process(event), react_on_text_message, etc для текущего состояния
# - /reenter — вручную стриггерить функцию enter_state у текущего состояния
# Кажется, такие штуки резко упростят разработку, отладку и финальную приёмку бота.

# TODO Программист -- по персональному токену подключиться к уже запущенному на сервере tg-боту
# Чтобы вместо запуска своего разработческого tg-бота использовать для отладки своего кода бота, уже запущенного на сервере
# Возможно, эту фичу стоит вынести в отдельный прокси микро-сервис и даже объединить с flood limiter в TgBotGate
