Пользователь — Написать tg бота: !func-export
  Ещё нет Django-проекта: !story
    отказ:
      - В документации вижу отсылку к чужим туториалам по сетапу Django-проекта с нуля

  Уже существующий Django-проект: !story
    сделано: no
    ситуация:
      - не знает как подключть webhook-сервер
      - знаком с Django
    успех:
      - Бот ответил на моё сообщение

  Подключиться к боту, уже запущенному в облаке: !extension

  Ответить пользователю: !story
    # TODO про conversation_var и SendMessageRequest

  Предложить пользователю нажать на кнопку: !story
    успех:
      - Бот ответил на нажатие кнопки

  Диалог с пагинацией: !story

  Запомнить выбор пользователя из списка: !story
    ситуация:
      - За пользователем закреплено несколько заказов в БД, у каждого свой ID
      - Пользовать ранее выбрал интересующий заказ
      - Пользователь запрашивает информацию по выбранному заказу

  Визард форм: !story
    ситуация:
      - Пользователь пошагово уточняет свой выбор:_ страна, товар, опции
      - Каждое следующее сообщение бота должно учитывать выбор ранее сделанный пользователем

  Свой контекст при вызове стейт-машины: !story
    ситуация:
      - перед включением стейт-машины надо выбрать локаль(язык) пользователя
      - локаль хранится в contextvar

  Своя модель вместо стандартной Conversation: !extension

  # TODO Больше частых ситуаций


Программист — Спросить помощи у сообщества: !func-export
  Попасть в раздел для сообщества: !story
    сделано: no
    ситуация:
      - Пользователи фреймворка хотят обмениваться опытом и помогать друг другу
    успех:
      - Вижу свой вопрос на форуме


Пользователь — Обновить свой Django-проект до свежей версии фреймворка: !func-export


Программист -- Сохранить в стейте id только что отправленного сообщения: !func
  # FIXME Как? Запись в стейт == изменение состояния с сохранением класса состояния

Программист — Промигрировать стейт-машину: !function
  Нет персистенции: !story  # Достаточно перезапустить программу
  Персистенция, но данные протухают за несколько дней: !story  # Достаточно преобразования в момент чтения состония из БД
  Персистенция с протухающими данными, но канареечная схема релизов: !story  # С БД работает одновременно и старая и новая версия кода
  Вечная персистенция: !story  # Нужен аналог миграции схемы БД

Программист — Сохранить и восстановить стейт-машину между запусками: !function
  локатор не найден: !story

Программист — Добавить обработчик события: !function
  on_chunk received: !story  # парсер бинарного файла
  on_message чат-бот: !story  # от пользователя прилетело текстовое сообщение
  on_enter + on_leave чат-бот: !story  # кнопочный чат-бот, хотим деактивировать кнопки под сообщением после
  HTTP POST, GET, PATCH: !story

# TODO Программист — Отрисовать схему и приложить документацию к ней: !function
# swagger-like

# TODO Исключено: На один URL зарегистрировать разные схемы данных

# TODO
# Программист — Совместить несколько роутеров в одном: !function
#   Подключить third party роутер к tg-боту: !story
#   Раскидать код tg-бота по разным модулям: !story

# TODO Добавить поддержку относительный адресов, при которой часть атрибутов заполняется автоматически
# Пример с парсером Dicom: сразу пять State для обработки body, и всем им нужны одни и те же аттрибуты
# Каждый раз в route.locate приходится передавать всё тот же набор аргументов:
# return router.locate(
#     '/body/fixed_length_tag_payload/',
#     vr_is_implicit=self.vr_is_implicit,
#     endian_is_little=self.endian_is_little,
#     ...


# TODO Нужен ещё один декоратор для ускорения отладки -- перехватываем исключения внутри стейта и отправляем
# пользователю сообщение в Tg с трейсбеком, адресом состояния и его параметрами. Так программист быстрее заметит
# где и в какой момент случился сбой.
# Такой декоратор пригодится при отладке в local-окружении, а на сервере его можно отключить.


# Ещё идеи для отладочных команд:
# - /pwd — вывести локатор текущего стейта и значения параметров в формате, пригодном для быстрого копирования
# - /cd ${...json_params...} — перевести стейт машину в указанный стейт
# - /trace on/off — включить/выключить трассировку стейтов, чтобы при каждом переходе из старого стейта в новый бот присылал программисту в Tg локатор и параметры нового стейта
# - /freeze on/off — заморозить текущий стейт, отключив все переходы, чтобы отладить методы process(event), react_on_text_message, etc для текущего состояния
# - /reenter — вручную стриггерить функцию enter_state у текущего состояния
# Кажется, такие штуки резко упростят разработку, отладку и финальную приёмку бота.

# TODO Программист -- по персональному токену подключиться к уже запущенному на сервере tg-боту
# Чтобы вместо запуска своего разработческого tg-бота использовать для отладки своего кода бота, уже запущенного на сервере
# Возможно, эту фичу стоит вынести в отдельный прокси микро-сервис и даже объединить с flood limiter в TgBotGate
