Чат-бот: !concept
  Описание: |
    Чат-бот -- это чат-бот Telegram, код которого написан на Django Tg Bot Framework.
  Официальный Tg бот: !example |
    Для чат-бота зарегистрирован отдельный аккаунт бота Telegram. Через этот аккаунт бот получает и отправляет сообщения.
  Чат-бот с двумя Tg аккаунтами: !extension |  # TODO описать пример использования
    Один чат-бот действует сразу из-под двух разных аккаунтов бота Telegram.
  Чат-бот под аккаунтом Tg пользователя: !extension |
    Чат-бот действует из-под обычного пользовательского аккаунта, а не с аккаунта бота. Такое возможно с помощью
    библиотек подобных Telethon. Администрация Telegram против такого, но сам фреймворк Django Tg Bot Framework
    такого не запрещает.
    Такой чат-бот не может отправлять сообщения с кнопками, но может реагировать на обычный текстовый ввод.
  Один чат-бот с двумя стейт-машинами: !example |
    Чат-бот одновременно умеет общаться с пользователем в личке и реагировать на Inline Query. Каждому формату
    общения -- своя стейт-машина со специфической логикой.
  Два чат-бота в одном Django-проекте: !example |
    Один веб-сервис обслуживает работу сразу двух разных ботов: один для обычных пользователей, второй для менеджеров.
  Чат-бот с вебхуком: !example |
    Аккаунт бота Telegram настроен на работу через вебхук. Сервер Telegram будет присылать отдельный HTTP запрос
    на указанный вебхук при каждом событии в чате.
  Long polling чат-бот: !example
    Чат-бот подключается к серверам Telegram через протокол Long Polling.
  Чат-бот c рассылками: !example |
    Чат-бот помимо обычного интеграктивного режима "запрос пользователя -- ответ" проводит также и рассылки по базе
    пользователей. Часть таких рассылок запускаются по таймеру, другие -- вручную.
  Персональный чат-бот: !example |
    Пользователь общается с чат-ботом в личке.
  Приватный чат-бот: !example |
    Пользователь общается с чат-ботом в приватных чатах.
  Встраиваемый чат-бот: !example |
    Чат-бот в Telegram получает от пользователя сообщения типа inline_query. Это особый механизм, который позволяет
    боту реагировать на запросы пользователей прямо в их текущих чатах, предлагать меню действий на выбор без
    необходимости перехода в личный чат с ботом.
  Чат-бот с доставкой: !example |
    Чат-бот в Telegram получает от пользователя сообщения типа shipping_query, связанный с доставкой. Такой тип
    сообщения также требует стейт-машины для хранения контекста, но при этом взаимодействие пользователя с ботом
    происходит вне личного чата.
  Групповой чат-бот: !example |
    Бот общается сразу с несколькими пользователями в группе Telegram. Одна стейт-машина принимает сообщения от разных
    пользователей и отправляет сообщения разным.



Стейт-машина: !concept
  Определение: |
    Алгоритм особой структуры, реагирующий на различные внешние события переходом из одного своего состояния в другое.
    Между вызовами стейт-машины её состояние можно сериализовать, записать в БД, а позже восстановить без потерь.
    Англ.: State Machine.
  Стейт-машина с сайд-эффектами: !example |
    Работа стейт-машины помимо перехода между состояниями, как правило, имеет сайд-эффекты: запись в файлы и БД,
    отправка сообщений по сети, изменение shared состояния.
  Infinite state machine: !example |
    Не является конечной стейт-машиной (Finite State Machine). У машины ограничено количество не состояний, а их
    типов. Например, для типа состояния `/user-found/` возможны состояния с разным набором данных: 'name=Петя',
    'name=Вася', и т.д.
  Стейт-машина персонального чат-бота: !example |
    Пользователь общается с ботом в личке. Каждому пользователю -- одна отдельная стейт-машина.
  Стейт-машина приватного чат-бота: !example |
    Пользователь общается с ботом в приватных чатах. Сколько пользователь создал приватных чатов с ботом, столько
    будет и отдельных стейт-машин. Может быть несколько для одного пользователя.
  Стейт-машина Tg чат-бота для Inline Query: !example |
    Чат-бот в Telegram получает от пользователя сообщение типа inline_query. Это особый механизм, который позволяет
    боту реагировать на запросы пользователей прямо в их  текущих чатах, без необходимости перехода в отдельный чат с
    ботом.

    В ответ на inline_query бот может вернуть различные результаты (например, статьи, фотографии, видео) с помощью
    метода answerInlineQuery, а может вернуть и выпадающий список с менюшкой. В таких случаях может пригодиться
    стейт-машина, чтобы хранить контекст.

    Обработка Inline Query требует стейт-машины особого типа. Такая стейт-машина не может привязывать свою память к
    чатику с пользователем, потому что взаимодействие с ботом происходит вне чата и, потенциально, сразу в нескольких
    местах параллельно. Также никто не мешает пользователю параллельно работать с тем же ботом обычным способом. Одно
    другому не должно мешать.
  Стейт-машина Tg чат-бота для Shipping Query: !example |
    Чат-бот в Telegram получает от пользователя сообщение типа shipping_query. Такой тип сообщения также требует
    стейт-машины для хранения контекста, но при этом взаимодействие пользователя с ботом происходит вне чата. Внутри
    update-сообщений от сервера Telegram не указывает chat_id.
  Стейт-машина Tg чат-бота в группе: !example |
    Бот общается сразу с несколькими пользователями в группе Telegram. Одна стейт-машина принимает сообщения от разных
    пользователей и отправляет сообщения разным.
  Стейт-машина чат-бота c массовой рассылкой: !example |
    Чат-бот помимо обычного интеграктивного режима "запрос пользователя -- ответ" проводит также и рассылки по базе
    пользователей. Часть таких рассылок запускаются по таймеру или вручную -- без update-события от сервера Telegram.
    Рассылки включаются не через вебхук, а через события внутри веб-сервиса: изменилась запись в БД, время вышло,
    администратор нажал на кнопку в админке.
  Составная стейт-машина: !extension |
    Стейт-машина может использовать сразу несколько роутеров -- первый использует классы состояний из базы данных, а
    второй -- из кода.
  Cтейт-машина с разными контекстами для разных стейтов: !exclusion
    Исключаем ситуацию, когда группы стейт-классов требуют разные контексты, из-за чего становится затруднён переход
    из одного подмножества стейтов в другое.


Контекст стейт-машины: !concept
  Опеределение: |
    Контекст стейт-машины -- это набор сериализуемых данных, общих для всех состояний одной стейт-машины. Например, для
    персонального чат-бота контекст может включать в себя `chat_id` и `tg_user_id`.
  Контекст без идентификатора: !exclusion |
    У любого контекста обязан быть идентификатор, позволяющий найти данные и восстановить их перед запуском
    стейт-машины.


Состояние: !concept
  Определение: |
    Одно из множества возможных состояний стейт-машины. Определяет то, как стейт-машина будет реагировать на
    последующие события.
    Состояние обязательно сериализуемо, чтобы не мешать сериализации стейт-машины целиком.
    Англ.: State.
  Состояние с параметрами: !example |
    Состояние включает в себя набор специфических для этого состояния параметров. Например, состояние
    "оформление заказа" может содержать два параметра:

    ```python
    items: list[Item]
    delivery_address: str
    ```

    По мере того, как пользователь Tg-бота наполняет свою корзину заказа стейт-машина переходит из одного состояния
    "оформление заказа" в другое похожее, отличающееся только параметрами `items` и `delivery_address`.
  Вход и выход: !example |
    Кнопочный чат-бот сначала отправляет пользователю сообщение с кнопками и просит того сделать выбор, а после ввода
    деактивирует либо прячет старые кнопки. Чтобы менять кнопки стейт-машина запускает код управления клавиатурой при
    каждом переходе из одного состояния в другое -- на входе и на выходе из состояния.
  Принудительное переключение без события: !example |
    В процессе разработки программист принудительно переводит бота из одного состояния в другое, не дожидаясь
    какого-либо внешнего события: Update объекта от Tg и/или события в БД. Также администратор в админке принудительно
    переводит бота из одного состояния в другое по просьбе пользователя.
  Зацикливание: !example |
    Чат-бот находится в состоянии `/start/` и предлагает пользователю выбрать пункт меню. Тут пользователь повторно
    вводит команду `/start` и ожидает получить от чат-бота новое такое же сообщение с выбором пункта меню. Получается,
    что конечное состояние не отличается от начального, но при этом код отрабатал так, словно произошли выход из
    состояния и повторный вход.


Класс состояний: !concept
  Определение: |
    Шаблон однотипных Состояний, имеющих общую схему параметров и общий код реакции на события.
    Стейт-машина использует классы состояний как шаблон для создания новых Состояний в процессе своей работы.
    Англ.: State Class.
  Стартовая точка: !example |
    Класс состояний может являться стартовой точкой — отсюда начинает свою работу конечный автомат.


Декоратор: !concept
  Определение: |
    Декоратор превращает один класс состоний в новый класс с расширенной логикой.
  Редирект по команде пользователя: !example |
    Пользователь ввёл команду /start -- декоратор отреагировал переводом стейт-машины в состояние `/start/`.
  Prompt: !example |
    При переходе стейт-машины в новое состояние декоратор отправляет пользователю текстовое сообщение с клавиатурой и
    предложением сделать выбор. На выходе из состояния декоратор меняет сообщение в чате Telegram, чтобы спрятать
    клавиатуру.


Локатор: !concept
  Описание: |
    Локатор -- это набор данных, который позволяет в точности восстановить состояние стейт-машины.
  Локатор в виде IRI: !example |  # TODO добавить в пример параметры и составной id чата
    IRI -- это аналог URL с поддержкой Unicode-символов.
    Пример локатора: `yostate://7329@default_personal_bot/main-menu/`, где:
      - `yostate` -- название протокола;
      - `7329` -- id контекста, например, conversation_id или chat_id;
      - `default_personal_bot` -- id стейт-машины, уникальный в рамках Django-проекта;
      - `/main-menu/` -- задаёт класс состояний.
  Локатор без явно указанной стейт-машины: !example |
    В одном Django-проекте используется только одна стейт-машина. Используются упрощённые локаторы без явного указания
    стейт-машины.
  Локатор с явно указанной стейт-машиной: !example |
    В одном Django-проекте используется несколько стейт-машины. Локатор включает в себя id стейт-машины.
  Локатор относительно текущей стейт-машины: !example |
    Код одного стейта ссылается на соседний стейт без явного указания в локаторе id стейт-машины. Подразумевается, что
    оба стейта находятся в одной стейт-машине, поэтому явно её можно не указывать.
  Локатор с id чата: !example |
    Стейт-машина в качестве id контекста использует id чата Telegram, в котором происходит переписка с пользователем.
  Локатор с id пользователя: !example |
    Стейт-машина в качестве id контекста использует id пользователя Telegram, с которым ведёт диалог чат-бот.
  Локатор с параметрами: !example  # TODO Привести пример записи в формате IRI
  Локатор с вложенными параметрами: !example  # TODO Привести пример записи в формате IRI


Локатор класса состояний: !concept
  Определение: |
    Идентификатор позволяет найти класс состояний в коде, чтобы восстановить стейт-машину. Выглядит как строка,
    похожая на путь файловой системы и на одноимённую часть URL (path), например `/menu/order_form/confirmation/`.
    Локатор класса состояний обязательно сериализуем.
    Англ.: State Class Locator (en).
  Root: !example |
    По аналогии с файловой системой и URL-адресами стандартным локатором для точки старта можно указать слэш `/`.
  Профиль пользователя: !example |
    Пример локатора для состояния чат-бота, когда пользователь запросил инфо по своему профилю: `/user/profile/`.
  Два локатора одного класса состояний: !example |
    Один класс состояний доступен сразу по нескольким локатором. Такое возможно, если важна обратная совместимость
    со старыми локаторами, ранее записанными в БД.
    Локатор не может содержать внутри себя данные, подобно url `/user/:username:/`. Параметры нужны при описании
    состояние, но не для класса состояний. А локатор указывает именно что на класс состояний.
  Параметры: !exclusion |
  # TODO Разрешить или запретить юникод? С какими целями?
  # Юникод: !exclusion |
  #   Локатор может быть только в ASCII-кодировке с использованием лишь самых простых символов: цифры буквы,
  #   подчёркивания, etc.
  #   Но зачем ?


Роутер: !concept
  Определение: |
    Обеспечивает связь между различными состояниями, объединяя их в единую схему. Позволяет восстановить состояние по
    его локатору и параметрам.
    Англ.: Router (en).
  Автоматическая декорация: !example |
    Каждый класс состояний при регистрации в роутере автоматически оборачивается декоратором в новый класс с
    дополнительной логикой.


Маршрут: !concept
  Определение: |
    Match Pattern for State Class Locator + State Class
    Англ.: Route


Событие: !concept
  Определение: |
    Событие приводит к запуску стейт-машины и может перевести её в новое состояние.
    Англ.: Event Type
  Сообщение от пользователя чат-бота: !example |
    От пользователя чат-бота прилетело новое текстовое сообщение.
  Команда Telegram: !example |
    Пользователь прислал в сообщении команду /start или что-то подобное. Бот замечает команду и реагирует на неё
    единообразно, вне зависимости от того, в каком состоянии сейчас он находится.
  HTTP POST, GET, PATCH: !example |
    У Telegram бота может быть своё веб-API, например, для интеграции с платёжной системой или HTML-формами лендингов.
    Тогда, входящие HTTP запросы будут переводить стейт-машину из одного состояния в другое. Получается, что бот
    реагирует на такие HTTP запросы как на события.
  Таймер сработал: !example |
    Стейт-машина отвечает за рассылку по целой базе пользователей. Она включается не через вебхук, а по таймеру.
  Кнопка в админке: !example |
    Администратор нажал на кнопку в админке, чтобы вручную запустить стейт-машину рассылки по базе пользователей.
  Кастомное событие: !example |
    Прикладной код запускает стейт-машину по специфическим событиями в базах данных.
