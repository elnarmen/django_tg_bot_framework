Стейт-машина: !concept
  Определение: |
    Алгоритм особой структуры, реагирующий на различные внешние события переходом из одного своего состояния в другое.
    Между вызовами стейт-машины её состояние можно сериализовать, записать в БД, а позже восстановить без потерь.
    Англ.: State Machine.
  Стейт-машина с сайд-эффектами: !example |
    Работа стейт-машины помимо перехода между состояниями, как правило, имеет сайд-эффекты: запись в файлы и БД,
    отправка сообщений по сети, изменение shared состояния.
  Infinite state machine: !example |
    Не является конечной стейт-машиной (Finite State Machine). У машины ограничено количество не состояний, а их
    типов. Например, для типа состояния `/user-found/` возможны состояния с разным набором данных: 'name=Петя',
    'name=Вася', и т.д.
  Стейт-машина персонального чат-бота: !example |
    Пользователь общается с ботом в личке. Каждому пользователю -- одна отдельная стейт-машина.
  Стейт-машина приватного чат-бота: !example |
    Пользователь общается с ботом в приватных чатах. Сколько пользователь создал приватных чатов с ботом, столько
    будет и отдельных стейт-машин. Может быть несколько для одного пользователя.
  Стейт-машина Tg чат-бота для Inline Query: !example |
    Чат-бот в Telegram получает от пользователя сообщение типа inline_query. Это особый механизм, который позволяет
    боту реагировать на запросы пользователей прямо в их  текущих чатах, без необходимости перехода в отдельный чат с ботом.

    В ответ на inline_query бот может вернуть различные результаты (например, статьи, фотографии, видео) с помощью
    метода answerInlineQuery, а может вернуть и выпадающий список с менюшкой. В таких случаях может пригодиться
    стейт-машина, чтобы хранить контекст.

    Обработка Inline Query требует стейт-машины особого типа. Такая стейт-машина не может привязывать свою память к
    чатику с пользователем, потому что взаимодействие с ботом происходит вне чата и, потенциально, сразу в нескольких
    местах параллельно. Также никто не мешает пользователю параллельно работать с тем же ботом обычным способом. Одно
    другому не должно мешать.
  Стейт-машина Tg чат-бота для Shipping Query: !example |
    Чат-бот в Telegram получает от пользователя сообщение типа shipping_query. Такой тип сообщения также требует
    стейт-машины для хранения контекста, но при этом взаимодействие пользователя с ботом происходит вне чата. Внутри
    update-сообщений от сервера Telegram не указывает chat_id.
  Стейт-машина Tg чат-бота в группе: !example |
    Бот общается сразу с несколькими пользователями в группе Telegram. Одна стейт-машина принимает сообщения от разных
    пользователей и отправляет сообщения разным.
  Стейт-машина чат-бота c массовой рассылкой: !example |
    Чат-бот помимо обычного интеграктивного режима "запрос пользователя -- ответ" проводит также и рассылки по базе
    пользователей. Часть таких рассылок запускаются по таймеру или вручную -- без update-события от сервера Telegram.
    Рассылки включаются не через веб-хук, а через события внутри веб-сервиса: изменилась запись в БД, время вышло,
    администратор нажал на кнопку в админке.
  Составная стейт-машина: !extension |
    Стейт-машина может использовать сразу несколько роутеров -- первый использует классы состояний из базы данных, а второй
    -- из кода.


Состояние: !concept
  Определение: |
    Одно из множества возможных состояний стейт-машины. Определяет то, как стейт-машина будет реагировать на
    последующие события.
    Состояние обязательно сериализуемо, чтобы не мешать сериализации стейт-машины целиком.
    Англ.: State.
  Состояние с параметрами: !example |
    Состояние включает в себя набор специфических для этого состояния параметров. Например, состояние
    "оформление заказа" может содержать два параметра:

    ```python
    items: list[Item]
    delivery_address: str
    ```

    По мере того, как пользователь Tg-бота наполняет свою корзину заказа стейт-машина переходит из одного состояния
    "оформление заказа" в другое похожее, отличающееся только параметрами `items` и `delivery_address`.
  Вход и выход: !example |
    Кнопочный чат-бот сначала отправляет пользователю сообщение с кнопками и просит того сделать выбор, а после ввода
    деактивирует либо прячет старые кнопки. Чтобы менять кнопки стейт-машина запускает код управления клавиатурой при каждом
    переходе из одного состояния в другое -- на входе и на выходе из состояния.
  Принудительное переключение без события: !example |
    В процессе разработки программист принудительно переводит бота из одного состояния в другое, не дожидаясь какого-либо внешнего
    события: Update объекта от Tg и/или события в БД. Также администратор в админке принудительно переводит бота из одного
    состояния в другое по просьбе пользователя.
  Зацикливание: !example |
    Чат-бот находится в состоянии `/start/` и предлагает пользователю выбрать пункт меню. Тут пользователь повторно вводит команду
    `/start` и ожидает получить от чат-бота новое такое же сообщение с выбором пункта меню. Получается, что конечное состояние не
    отличается от начального, но при этом код отрабатал так, словно произошли выход из состояния и повторный вход.


Класс состояний: !concept
  Определение: |
    Шаблон однотипных Состояний, имеющих общую схему параметров и общий код реакции на события.
    Стейт-машина использует классы состояний как шаблон для создания новых Состояний в процессе своей работы.
    Англ.: State Class.
  Стартовая точка: !example |
    Класс состояний может являться стартовой точкой — отсюда начинает свою работу конечный автомат.


Декоратор: !concept
  Определение: |
    Декоратор превращает один класс состоний в новый класс с расширенной логикой.
  Редирект по команде пользователя: !example |
    Пользователь ввёл команду /start -- декоратор отреагировал переводом стейт-машины в состояние `/start/`.
  Prompt: !example |
    При переходе стейт-машины в новое состояние декоратор отправляет пользователю текстовое сообщение с клавиатурой и
    предложением сделать выбор. На выходе из состояния декоратор меняет сообщение в чате Telegram, чтобы спрятать клавиатуру.


Локатор класса состояний: !concept
  Определение: |
    Идентификатор позволяет найти класс состояний в коде, чтобы восстановить стейт-машину. Выглядит как строка,
    похожая на путь файловой системы и на одноимённую часть URL (path), например `/menu/order_form/confirmation/`.
    Локатор класса состояний обязательно сериализуем.
    Англ.: State Class Locator (en).
  Root: !example |
    По аналогии с файловой системой и URL-адресами стандартным локатором для точки старта можно указать слэш `/`.
  Профиль пользователя: !example |
    Пример локатора для состояния чат-бота, когда пользователь запросил инфо по своему профилю: `/user/profile/`.
  Два локатора одного класса состояний: !example |
    Один класс состояний доступен сразу по нескольким локатором. Такое возможно, если важна обратная совместимость
    со старыми локаторами, ранее записанными в БД.
  Параметры: !excluded |
    Локатор не может содержать внутри себя данные, подобно url `/user/:username:/`. Параметры нужны при описании состояние,
    но не для класса состояний. А локатор указывает именно что на класс состояний.
  # TODO Разрешить или запретить юникод? С какими целями?
  # Юникод: !excluded |
  #   Локатор может быть только в ASCII-кодировке с использованием лишь самых простых символов: цифры буквы, подчёркивания, etc.
  #   Но зачем ?


Роутер: !concept
  Определение: |
    Обеспечивает связь между различными состояниями, объединяя их в единую схему. Позволяет восстановить состояние по его
    локатору и параметрам.
    Англ.: Router (en).
  Автоматическая декорация: !example |
    Каждый класс состояний при регистрации в роутере автоматически оборачивается декоратором в новый класс с дополнительной логикой.


Маршрут: !concept
  Определение: |
    Match Pattern for State Class Locator + State Class
    Англ.: Route


Событие: !concept
  Определение: |
    Событие приводит к запуску стейт-машины и может перевести её в новое состояние.
    Англ.: Event Type
  Сообщение от пользователя чат-бота: !example |
    От пользователя чат-бота прилетело новое текстовое сообщение.
  Команда Telegram: !example |
    Пользователь прислал в сообщении команду /start или что-то подобное. Бот замечает команду и реагирует на неё единообразно, вне
    зависимости от того, в каком состоянии сейчас он находится.
  HTTP POST, GET, PATCH: !example |
    У Telegram бота может быть своё веб-API, и тогда входящие HTTP запросы будут переводить его из одного состояния в другое.
    Получается, что бот реагирует на HTTP запросы как на события.
  Таймер сработал: !example |
    Стейт-машина отвечает за рассылку по целой базе пользователей. Она включается не через веб-хук, а по таймеру.
  Кнопка в админке: !example |
    Администратор нажал на кнопку в админке, чтобы вручную запустить стейт-машину рассылки по базе пользователей.
  Кастомное событие: !example |
    Прикладной код запускает стейт-машину по специфическим событиями в базах данных.


Очередь событий: !concept
  Определение: |
    Очередь событий -- это аналог обычной очереди задач, где каждое событие рассматривается как задача, требующая обработки.
    От очереди задач отличается тем, что неудачная попытка обработки события не приводит к повторной попытке. Каждое
    событие привязано к одной из стейт-машин, и события одной стейт-машины обрабатываются строго в их хронологическом порядке.
